!  VERSION 1.0  (NLSPMC version)   2/5/99
!**********************************************************************

!                           =======
!                            CSVEC
!                           =======

!       This subroutine attempts to calculate the eigenvector
!       of the tridiagonal matrix corresponding to the eigenvalue
!       x.  The subroutine is written for a general complex symmetric
!       tridiagonal matrix, and it is based on the subroutine INVERM
!       of Cullum & Willoughby, vol. II page 430; CSVEC may be used
!       also in the case of Hermitian complex calculation, since the
!       tridiagonal matrix generated by Lanczos (or cg) algorithm
!       is real symmetrix.

!	The normalization process of the resulting eigenvector is
!	corrected for complex symmetric matrix: one can't use the
!	Hermitian norm.
!		z = tr(V)*V; v = V / sqrt(z)

!			V ; un-normalized eigenvector
!			v ; normalized eigenvector
!			z ; Euclidean norm, complex number

!       modified from original AP routine by Sanghyuk Lee

!       Arguments:
!           a    diagonal T matrix elements
!           b    extradiagonal T matrix elements
!           v1   work space
!           v2   work space, on exit = normalized eigenvector
!           x    eigenvalue
!           err  |v2(n)|  error estimate for corresponding ritz vector for x
!           errv |T*v2-x*v2| error estimate on T-eigenvector
!           gr   real part right hand vector
!           gc   complex part right hand vector
!           intc work space
!           n    order of T
!           it   max number of iteration
!           iwr  write flag for error

!       Includes:
!              nlsdim.inc
!              rndoff.inc

!       Uses:
!              znormu.f
!              zdotu2.f

!***********************************************************************

    subroutine csvec(a,b,v1,v2,x,err,errv,gr,gc,intc,n,it)

    include 'limits.inc'
    include 'rndoff.inc'

    integer :: intc,n,it
    double precision :: err,errv,gr,gc
    complex*16 a,b,v1,v2,x,cnorm
    dimension intc(mxstep),a(mxstep),b(mxstep), &
    v1(mxstep),v2(mxstep),gr(mxstep),gc(mxstep)

    integer :: iter,mp1,mm1,i,ii,j
    double precision :: xu,norm,tsum,gsum, &
                        eps,eps3,eps4,zero,one
    complex*16 u,z,temp,ratio,betam,czero,csum,cerrv
    complex*16 znormu,zdotu2
    external znormu,zdotu2

    parameter (czero=(0.0D0,0.0D0),one=1.0D0,zero=0.0D0)

!#######################################################################

    if(n > mxstep) then
        write(*,*)'n too big in csvec ',n,mxstep
        stop
    end if
    eps=100.0D0*rndoff

    do 10 i=1,mxstep
        gr(i)=zero
        gc(i)=zero
    10 END DO
    gr(1)=one
    gc(1)=one

!-----------------------------------------------------------------------
!      parameters
!-----------------------------------------------------------------------

    iter=it
    mp1=n+1
    mm1=n-1
    betam=b(n)
    b(n)=czero

!  calculate scale and tolerance
    tsum=zero
    do 15 i=1,n
        tsum=tsum+cdabs(a(i))+cdabs(b(i))
    15 END DO

    eps3=eps*tsum
    eps4=dble(n)*eps3

!  generate scaled right hand side
    gsum=zero
    do 20 i=1,n
        gsum=gsum+dabs(gr(i))+dabs(gc(i))
    20 END DO
    gsum=eps4/gsum

!  initialize right hand side for inverse iteration
    do 30 i=1,n
        intc(i)=0
        v2(i)=gsum*dcmplx(gr(i),gc(i))
    30 END DO

    it=1

!-----------------------------------------------------------------------
!      triangular factorization
!-----------------------------------------------------------------------

    40 continue

    u=a(1)-x
    z=b(1)

    do 60 i=2,n
        if (cdabs(b(i-1)) <= cdabs(u)) then
            v1(i-1)=z/u
            v2(i-1)=v2(i-1)/u
            v2(i)=v2(i)-b(i-1)*v2(i-1)
            ratio=b(i-1)/u
            u=a(i)-x-z*ratio
            z=b(i)
        else
            ratio=u/b(i-1)
            intc(i)=1
            v1(i-1)=a(i)-x
            u=z-ratio*v1(i-1)
            z=-ratio*b(i)
            temp=v2(i-1)
            v2(i-1)=v2(i)
            v2(i)=temp-ratio*v2(i)
        end if
    60 END DO

    if (cdabs(u) <= rndoff) u=dcmplx(eps3,eps3)

!  back substitution
    v2(n)=v2(n)/u
    do 80 ii=1,mm1
        i=n-ii
        if (intc(i+1) /= 1) then
            v2(i)=v2(i)-v1(i)*v2(i+1)
        else
            v2(i)=(v2(i)-v1(i)*v2(i+1)-b(i+1)*v2(i+2))/b(i)
        end if
    80 END DO

!-----------------------------------------------------------------------
!      tests for convergence of inverse iteration
!-----------------------------------------------------------------------

    norm=cdabs(v2(n))
    do 90 ii=1,mm1
        i=n-ii
        norm=norm+cdabs(v2(i))
    90 END DO

    if (norm >= one) go to 110

    it=it+1
    if (it > iter) go to 110

    xu=eps4/norm
    do 100 i=1,n
        intc(i)=0
        v2(i)=v2(i)*xu
    100 END DO

    go to 40

    110 continue

    csum=znormu(v2,n)

    do 120 ii=1,n
        v2(ii)=v2(ii)/csum
    120 END DO

    err=cdabs(v2(n))

    v1(n)=a(n)*v2(n)+b(n-1)*v2(n-1)-x*v2(n)

    do 130 j=2,mm1
        jm=mp1-j
        v1(jm)=a(jm)*v2(jm)+b(jm-1)*v2(jm-1)+b(jm)*v2(jm+1)-x*v2(jm)
    130 END DO

    v1(1)=a(1)*v2(1)+b(1)*v2(2)-x*v2(1)

    cerrv=zdotu2(v1,v1,n)
    errv=cdabs(cerrv)
    if (it > iter) errv=-errv

    b(n)=betam

    cnorm=czero
    do 1001 i=1,n
        cnorm=cnorm+(v2(i))**2
    1001 END DO
    write(luttyo,*) "Eigenvalue",x,"Norm of v2",cnorm
    return

    end subroutine csvec
